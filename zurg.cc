#include <iostream>
#include <string>
#include <list>
#include <algorithm>


/* 
 * Just name of the toy and time to cross the bridge
 */
class Toy {
    public:
        Toy(const char* name = "", int time = 0) : name_(name), time_(time) {}

        bool operator == (const Toy& val) {
            return name_ == val.name_;
        }

        std::string getName() const {
            return name_;
        }

        int getTime() const {
            return time_;
        }

        bool isNobody() const {
            return name_.empty();
        }

    private:
        std::string name_;
        int         time_;
};

/*
 * Either one or two toys can cross the bridge at the same time
 */
class Move {
    public:
        enum Direction { Left, Right };

        Move(const Toy& one, Direction dir) : first_(one), dir_(dir) {}
        Move(const Toy& first, const Toy& second, Direction dir) :
            first_(first), second_(second), dir_(dir) {}

        int cost() const {
            return std::max(first_.getTime(), second_.getTime());
        }

        Direction getDirection() const {
            return dir_;
        }

        std::vector<Toy> getToys() const {
            std::vector<Toy> ret;
            ret.push_back(first_);  // at least one traveller should exist
            if (!second_.isNobody())
                ret.push_back(second_);

            return ret;
        }

        friend std::ostream& operator << (std::ostream& out, const Move& mv);

    private:
        Toy first_;
        Toy second_;
        Direction dir_;
};

std::ostream& operator << (std::ostream& out, const Move& mv) {
    out << mv.first_.getName();
    if (mv.second_.isNobody()) {
        out << " goes ";
    } else {
        out << " and " << mv.second_.getName() << " go ";
    }
    out << ((mv.dir_ == Move::Right) ? "right": "left") << std::endl;

    return out;
}


/*
 * Represet current position (toys on both sides of the bridge and torch location)
 * and history of all moves
 */
class State {
    public:
        enum Torch { Left, Right };

        // initial position: all toys on the left side with torch
        explicit State(std::list<Toy> toys) : left_(toys) {
            cost_ = 0;
            torch_ = Left;
        }

        // returns new state after the move
        // I should really check if move is valid, but assume that Solver uses
        // only moves generated by me
        State next(Move mv) const {
            State ret = *this;

            std::vector<Toy> toys = mv.getToys();

            if (mv.getDirection() == Move::Right) {
                std::for_each(toys.begin(), toys.end(), [&ret](const Toy& toy) {
                    ret.left_.remove(toy);
                    ret.right_.push_back(toy);
                });
                ret.torch_ = Right;
            } else {
                std::for_each(toys.begin(), toys.end(), [&ret](const Toy& toy) {
                    ret.right_.remove(toy);
                    ret.left_.push_back(toy);
                });
                ret.torch_ = Left;
            }

            ret.cost_ += mv.cost();
            ret.moves_.push_back(mv);

            return ret;
        }

        // generate all possible moves for the current
        // position
        std::list<Move> next() {
            if (torch_ == Left) {
                return generateMoves(left_, Move::Right);
            } else {
                return generateMoves(right_, Move::Left);
            }
        }

        static std::list<Move> generateMoves(std::list<Toy> toys, Move::Direction dir) {
            std::list<Move> ret;

            // lets generate all possible moves and it's up to solver
            // to select proper ones
            std::for_each(toys.begin(), toys.end(), [&](const Toy& toy) {
                ret.push_back(Move(toy, dir));
            });

            // lets get combinatios
            for (std::list<Toy>::const_iterator iit = toys.begin(); iit != toys.end(); iit++) {
                for (std::list<Toy>::const_iterator jit = iit; jit != toys.end(); jit++) {
                    // why list iterator doesn't have + operator ;-)
                    if (jit == iit)
                        continue;
                    ret.push_back(Move(*iit, *jit, dir));
                }
            }

            return ret;
        }

        bool isSolved() const {
            return left_.empty();
        }

        int getCost() const {
            return cost_;
        }

        friend std::ostream& operator << (std::ostream& out, const State& state);

    private:
        std::list<Toy> left_;
        std::list<Toy> right_;
        std::vector<Move> moves_;

        int cost_;
        Torch torch_;
};


std::ostream& operator << (std::ostream& out, const State& state) {
    out << "Time: " << state.cost_ << std::endl;
    std::for_each(state.moves_.begin(), state.moves_.end(), [&](const Move& mv) {
        out << mv;
    });

    return out;
}

/* 
 * problem solver 
 */
class SearchProblem {
    public:
        std::vector<State> solve(std::list<Toy> toys) {
            State initial(toys);
            solve(initial);

            return solutions_;
        }

    private:
        void solve(State state) {
            std::list<Move> lst = state.next();
            if (lst.empty()) {
                std::cout << "List of moves is empty\n";
                return;
            }

            std::for_each(lst.begin(), lst.end(), [&](const Move& mv) {
                // Two toys can go right and one toy can go left
                if ((mv.getDirection() == Move::Right && mv.getToys().size() == 2) ||
                    (mv.getDirection() == Move::Left && mv.getToys().size() == 1)) {
                    State st = state.next(mv);
                    if (st.isSolved() && st.getCost() <= 60) {
                        // solution is found
                        solutions_.push_back(st);
                    } else {
                        solve(st);
                    }
                }
            });
        }

    private:
        std::vector<State> solutions_;
};

int main(int argc, char** argv) {
    Toy toys[4] = { {"Buzz", 5}, {"Woody", 10}, {"Rex", 20}, {"Hamm", 25} };

    SearchProblem problem;
    std::vector<State> solutions = problem.solve(std::list<Toy>(&(toys[0]), &(toys[4])));

    std::for_each(solutions.begin(), solutions.end(), [&] (const State& st) {
        std::cout << st << std::endl;
    });

    return 0;
}
